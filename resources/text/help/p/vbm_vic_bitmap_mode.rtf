<h3>vbm - Vic Bitmap Mode</h3>
<p>
    The Vic 20 does not have a true bitmap display mode like the Commodore 64 but it does have some tricks up its sleeve to allow a bitmap to be created out of characters.
</p>

<p>
    The vic chip which is used to generate what you see on the screen has the following properties:
</p>
<ol>
    <li>The address for how to display characters can either be RAM between $1000 and $1FFF or the default ROM from $8000</li>
    <li>The screen can be set to RAM between $1000 and $1FFF</li>
</ol>
<p>
    By setting the character address to RAM we can redefine the default Vic 20 characters from A, B, C etc to a spaceship, pacman or a sheep.  Most Vic 20 programmers would have done this when making a game.
</p>
<p>
    The Vic Bitmap Mode works as follows:  
</p>
<ol>
    <li>The screen and the character addresses are both set to $1000</li>
    <li>Double sized character mode is enabled, so one byte in screen memory displays two characters (one on top of the other)</li>
    <li>The Vic 20 screen is set to 20 character wide by 12 double characters high (or 24 single characters)</li>
    <li>Characters 0 - 15 are skipped, the space in memory these characters occupy is equivalent to the number of bytes needed for the screen display</li>
    <li>Characters are drawn into screen memory at $1000 (the top left) downwards, starting from character 16 (which is a space and an "), then 17 underneath, 18, 19 and so of and repeated for each column. A total of 240 characters are written to screen memory in this pattern</li>
    <li>Addresses from $1100 to $1FFF point to a character definintions, starting at character 16.</li>
</ol>

<p>
    So with the above set up, writing to any address between $1100 through to $1FFF will draw onto the bitmap by redefining characters.
</p>

<p>
    The double height characters are drawn to the screen in rows rather than columns to make it simplier to draw to the bitmap.  Writing 255 ($ff or %11111111) to address $1100 will show a line of 8 pixels at the top left of the screen.  Writing to $1101 will do the same for the next pixel row down. Each consecutive byte from $1100 to $11C0 (192) makes up a row of 8 pixels in the first column.  The next column then starts at $11C1 and ends at $1280, each of the 20 columns are accessible in this way.
</p>

<p>
    In Turbo Rascal there are a number of vbm commands to help you make the most of this bitmap, so you don't have to figure out how to write to it yourself.  There are commands to set up the screen, locate a column address in the bitmap, draw dots (pixels), tiles, sprites and text.  You can, of course, create your own routines in Turbo Rascal or assembler to draw to the bitmap - the choice is yours!
</p>

<p>
    There is documentation for each vbm command and a selection of tutorials to get you started.  The power to make the next Omega Race is now in your hands.  Have fun!
</p>

<h3>Example</h3>
<p>Here is an example program that sets up vbm and draws a pattern to the bitmap which you will see on the screen.</p>
<pre>
program DrawOnBitmap;
var

@startblock $2000 "CODE"

    x,y :byte;
    p1 : pointer;

// Fill the colour memory with 0 (Black)
procedure ScreenClearColour();
begin

    for y := 0 to 192 do
    begin
    
        screenmemory := $9400 + (y * 20);
        for x := 0 to 20 do
            screenmemory[ x ] := 0;

    end;

end;


begin  /* MAIN PROGRAM */

    SCREEN_BG_COLOR := SCREEN_BG_WHITE + WHITE;

    vbmSetDisplayMode();        // set up the Vic Bitmap Mode - this must be done first

    vbmClear(0);                // clear the bitmap with byte 0 (empty)

    ScreenClearColour();        // set the colour map to black

    // draw pattern 
    for x:= 0 to 20 do	        // there are 8-pixel 20 columns
        for y := 0 to 192 do    // there are 192 pixel rows
        begin

            vbmSetColumn(x);        // set the screenmemory pointer to a specific column
            screenmemory[y] := x+y; // write a byte pattern to the screenmemory (the bitmap memory)

        end;

    loop();

end.
</pre>

<p>
    VBM was created by Andy H and integrated into Turbo Rascal for every Vic 20 programmer to use.  Thanks must go to Mike and DarwinNE from the Vic 20 Denial forum who pointed me in the right direction to make use of this trick to allow a full screen bitmap to be laid out.
</p>